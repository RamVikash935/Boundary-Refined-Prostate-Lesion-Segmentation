#    Copyright 2020 Division of Medical Image Computing, German Cancer Research Center (DKFZ), Heidelberg, Germany
#
#    Licensed under the Apache License, Version 2.0 (the "License");
#    you may not use this file except in compliance with the License.
#    You may obtain a copy of the License at
#
#        http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS,
#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#    See the License for the specific language governing permissions and
#    limitations under the License.

import sys
import os

sys.path.append(os.path.abspath('/home/ss_students/zywx/main_file/all_helper_fn_n_class'))


import torch
import torch._dynamo

# Suppress Triton-related errors and fallback to eager mode
torch._dynamo.config.suppress_errors = True

import warnings
warnings.filterwarnings("ignore", category=UserWarning)  # Ignores only UserWarnings

import logging
logging.getLogger("torch._dynamo").setLevel(logging.ERROR)  # Hides TorchDynamo warnings

import shutil
from collections import OrderedDict
from multiprocessing import Pool
from time import sleep
from typing import Tuple, List

import matplotlib
import numpy as np
import torch
from batchgenerators.utilities_file_and_folder_operations import *
from torch import nn
from torch.optim import lr_scheduler

from configuration import default_num_threads
from evaluation_evaluator import aggregate_scores
from inference_segmentation_export import save_segmentation_nifti_from_softmax
from network_architectures_generic_UNet import Generic_UNet
from network_architectures_initialization import InitWeights_He
from network_architectures_neural_network import SegmentationNetwork
from postprocessing_connected_components import determine_postprocessing
from training_default_data_augmentation import default_3D_augmentation_params, default_2D_augmentation_params, get_default_augmentation, get_patch_size
from training_dataloading_dataset_loading import load_dataset, DataLoader3D, DataLoader2D, unpack_dataset
from training_loss_functions_dice_loss import DC_and_CE_loss
from training_network_network_trainer import NetworkTrainer
from utilities import softmax_helper, sum_tensor

matplotlib.use("agg")


class nnUNetTrainer(NetworkTrainer):
    def __init__(self, plans_file, fold, output_folder=None, dataset_directory=None, batch_dice=True, stage=None,
                 unpack_data=True, deterministic=True, fp16=False):
        """
        :param deterministic:
        :param fold: can be either [0 ... 5) for cross-validation, 'all' to train on all available training data or
        None if you wish to load some checkpoint and do inference only
        :param plans_file: the pkl file generated by preprocessing. This file will determine all design choices
        :param subfolder_with_preprocessed_data: must be a subfolder of dataset_directory (just the name of the folder,
        not the entire path). This is where the preprocessed data lies that will be used for network training. We made
        this explicitly available so that differently preprocessed data can coexist and the user can choose what to use.
        Can be None if you are doing inference only.
        :param output_folder: where to store parameters, plot progress and to the validation
        :param dataset_directory: the parent directory in which the preprocessed Task data is stored. This is required
        because the split information is stored in this directory. For running prediction only this input is not
        required and may be set to None
        :param batch_dice: compute dice loss for each sample and average over all samples in the batch or pretend the
        batch is a pseudo volume?
        :param stage: The plans file may contain several stages (used for lowres / highres / pyramid). Stage must be
        specified for training:
        if stage 1 exists then stage 1 is the high resolution stage, otherwise it's 0
        :param unpack_data: if False, npz preprocessed data will not be unpacked to npy. This consumes less space but
        is considerably slower! Running unpack_data=False with 2d should never be done!

        IMPORTANT: If you inherit from nnUNetTrainer and the init args change then you need to redefine self.init_args
        in your init accordingly. Otherwise checkpoints won't load properly!
        """
        super(nnUNetTrainer, self).__init__(deterministic, fp16)
        print("DEBUG: Called super().__init__(deterministic, fp16)")

        self.unpack_data = unpack_data
        print(f"DEBUG: Set self.unpack_data = {self.unpack_data}")

        self.init_args = (plans_file, fold, output_folder, dataset_directory, batch_dice, stage, unpack_data,
                          deterministic, fp16)
        print(f"DEBUG: Initialized self.init_args = {self.init_args}")

        # set through arguments from init
        self.stage = stage
        print(f"DEBUG: Set self.stage = {self.stage}")

        self.experiment_name = self.__class__.__name__
        print(f"DEBUG: Set self.experiment_name = {self.experiment_name}")

        self.plans_file = plans_file
        print(f"DEBUG: Set self.plans_file = {self.plans_file}")

        self.output_folder = output_folder
        print(f"DEBUG: Set self.output_folder = {self.output_folder}")

        self.dataset_directory = dataset_directory
        print(f"DEBUG: Set self.dataset_directory = {self.dataset_directory}")

        self.output_folder_base = self.output_folder
        print(f"DEBUG: Set self.output_folder_base = {self.output_folder_base}")

        self.fold = fold
        print(f"DEBUG: Set self.fold = {self.fold}")

        self.plans = None
        print("DEBUG: Set self.plans = None")

        # if we are running inference only then the self.dataset_directory is set (due to checkpoint loading) but it
        # irrelevant
        if self.dataset_directory is not None and isdir(self.dataset_directory):
            self.gt_niftis_folder = join(self.dataset_directory, "gt_segmentations")
            print(f"DEBUG: Dataset directory exists, set self.gt_niftis_folder = {self.gt_niftis_folder}")
        else:
            self.gt_niftis_folder = None
            print("DEBUG: Dataset directory invalid or None, set self.gt_niftis_folder = None")

        self.folder_with_preprocessed_data = None
        print("DEBUG: Set self.folder_with_preprocessed_data = None")

        # set in self.initialize()

        self.dl_tr = self.dl_val = None
        print("DEBUG: Set self.dl_tr and self.dl_val = None")

        self.num_input_channels = self.num_classes = self.net_pool_per_axis = self.patch_size = self.batch_size = \
            self.threeD = self.base_num_features = self.intensity_properties = self.normalization_schemes = \
            self.net_num_pool_op_kernel_sizes = self.net_conv_kernel_sizes = None  # loaded automatically from plans_file
        print("DEBUG: Initialized network parameters placeholders to None")

        self.basic_generator_patch_size = self.data_aug_params = self.transpose_forward = self.transpose_backward = None
        print("DEBUG: Initialized data augmentation and transpose placeholders to None")

        self.batch_dice = batch_dice
        print(f"DEBUG: Set self.batch_dice = {self.batch_dice}")

        self.loss = DC_and_CE_loss({'batch_dice': self.batch_dice, 'smooth': 1e-5, 'do_bg': False}, {})
        print(f"DEBUG: Created self.loss = {self.loss}")

        self.online_eval_foreground_dc = []
        print("DEBUG: Initialized self.online_eval_foreground_dc = []")

        self.online_eval_tp = []
        print("DEBUG: Initialized self.online_eval_tp = []")

        self.online_eval_fp = []
        print("DEBUG: Initialized self.online_eval_fp = []")

        self.online_eval_fn = []
        print("DEBUG: Initialized self.online_eval_fn = []")

        self.classes = self.do_dummy_2D_aug = self.use_mask_for_norm = self.only_keep_largest_connected_component = \
            self.min_region_size_per_class = self.min_size_per_class = None
        print("DEBUG: Initialized multiple config placeholders to None")

        self.inference_pad_border_mode = "constant"
        print(f"DEBUG: Set self.inference_pad_border_mode = {self.inference_pad_border_mode}")

        self.inference_pad_kwargs = {'constant_values': 0}
        print(f"DEBUG: Set self.inference_pad_kwargs = {self.inference_pad_kwargs}")

        self.update_fold(fold)
        print(f"DEBUG: Called update_fold({fold})")

        self.pad_all_sides = None
        print("DEBUG: Set self.pad_all_sides = None")

        self.lr_scheduler_eps = 1e-3
        print(f"DEBUG: Set self.lr_scheduler_eps = {self.lr_scheduler_eps}")

        self.lr_scheduler_patience = 30
        print(f"DEBUG: Set self.lr_scheduler_patience = {self.lr_scheduler_patience}")

        self.initial_lr = 3e-4
        print(f"DEBUG: Set self.initial_lr = {self.initial_lr}")

        self.weight_decay = 3e-5
        print(f"DEBUG: Set self.weight_decay = {self.weight_decay}")

        self.oversample_foreground_percent = 0.33
        print(f"DEBUG: Set self.oversample_foreground_percent = {self.oversample_foreground_percent}")

        self.conv_per_stage = None
        print("DEBUG: Set self.conv_per_stage = None")

        self.regions_class_order = None
        print("DEBUG: Set self.regions_class_order = None")



    def update_fold(self, fold):
        """
        used to swap between folds for inference (ensemble of models from cross-validation)
        DO NOT USE DURING TRAINING AS THIS WILL NOT UPDATE THE DATASET SPLIT AND THE DATA AUGMENTATION GENERATORS
        :param fold:
        :return:
        """
        # print(f"DEBUG: Entering update_fold with fold={fold}")
        if fold is not None:
            if isinstance(fold, str):
                print("DEBUG: fold is a string")
                assert fold == "all", "if self.fold is a string then it must be 'all'"
                if self.output_folder.endswith(f"{self.fold}"):
                    self.output_folder = self.output_folder_base
                    print(f"DEBUG: Reset output_folder to base: {self.output_folder}")
                self.output_folder = join(self.output_folder, f"{fold}")
                print(f"DEBUG: Appended string fold to output_folder: {self.output_folder}")
            else:
                # print("DEBUG: fold is not a string")
                if self.output_folder.endswith(f"fold_{self.fold}"):
                    self.output_folder = self.output_folder_base
                    # print(f"DEBUG: Reset output_folder to base: {self.output_folder}")
                self.output_folder = join(self.output_folder, f"fold_{fold}")
                # print(f"DEBUG: Appended numeric fold to output_folder: {self.output_folder}")
            self.fold = fold
            # print(f"DEBUG: Updated self.fold to {self.fold}")

    def setup_DA_params(self):
        print("DEBUG: Entering setup_DA_params")
        if self.threeD:
            print("DEBUG: Using 3D data augmentation")
            self.data_aug_params = default_3D_augmentation_params
            print(f"DEBUG: Set data_aug_params = default_3D_augmentation_params: {self.data_aug_params}")
            if self.do_dummy_2D_aug:
                print("DEBUG: do_dummy_2D_aug is True")
                self.data_aug_params["dummy_2D"] = True
                print("DEBUG: Enabled dummy_2D in data_aug_params")
                self.print_to_log_file("Using dummy2d data augmentation")
                self.data_aug_params["elastic_deform_alpha"] = default_2D_augmentation_params["elastic_deform_alpha"]
                print(f"DEBUG: Set elastic_deform_alpha = {self.data_aug_params['elastic_deform_alpha']}")
                self.data_aug_params["elastic_deform_sigma"] = default_2D_augmentation_params["elastic_deform_sigma"]
                print(f"DEBUG: Set elastic_deform_sigma = {self.data_aug_params['elastic_deform_sigma']}")
                self.data_aug_params["rotation_x"] = default_2D_augmentation_params["rotation_x"]
                print(f"DEBUG: Set rotation_x = {self.data_aug_params['rotation_x']}")
        else:
            print("DEBUG: Using 2D data augmentation")
            self.do_dummy_2D_aug = False
            print("DEBUG: Set do_dummy_2D_aug = False")
            if max(self.patch_size) / min(self.patch_size) > 1.5:
                default_2D_augmentation_params['rotation_x'] = (-15. / 360 * 2. * np.pi, 15. / 360 * 2. * np.pi)
                print(f"DEBUG: Adjusted default rotation_x for anisotropic patches: {default_2D_augmentation_params['rotation_x']}")
            self.data_aug_params = default_2D_augmentation_params
            print(f"DEBUG: Set data_aug_params = default_2D_augmentation_params: {self.data_aug_params}")
        
        self.data_aug_params["mask_was_used_for_normalization"] = self.use_mask_for_norm
        print(f"DEBUG: Set mask_was_used_for_normalization = {self.use_mask_for_norm}")

        if self.do_dummy_2D_aug:
            print("DEBUG: Computing basic_generator_patch_size with dummy 2D aug")
            self.basic_generator_patch_size = get_patch_size(self.patch_size[1:],
                                                             self.data_aug_params['rotation_x'],
                                                             self.data_aug_params['rotation_y'],
                                                             self.data_aug_params['rotation_z'],
                                                             self.data_aug_params['scale_range'])
            print(f"DEBUG: basic_generator_patch_size after rotation and scale = {self.basic_generator_patch_size}")
            self.basic_generator_patch_size = np.array([self.patch_size[0]] + list(self.basic_generator_patch_size))
            print(f"DEBUG: final basic_generator_patch_size with depth channel = {self.basic_generator_patch_size}")
        else:
            print("DEBUG: Computing basic_generator_patch_size without dummy 2D aug")
            self.basic_generator_patch_size = get_patch_size(self.patch_size,
                                                             self.data_aug_params['rotation_x'],
                                                             self.data_aug_params['rotation_y'],
                                                             self.data_aug_params['rotation_z'],
                                                             self.data_aug_params['scale_range'])
            print(f"DEBUG: basic_generator_patch_size = {self.basic_generator_patch_size}")

        self.data_aug_params['selected_seg_channels'] = [0]
        print("DEBUG: Set selected_seg_channels = [0]")
        self.data_aug_params['patch_size_for_spatialtransform'] = self.patch_size
        print(f"DEBUG: Set patch_size_for_spatialtransform = {self.patch_size}")

    def initialize(self, training=True, force_load_plans=False):
        print(f"DEBUG: Entering initialize(training={training}, force_load_plans={force_load_plans})")
        maybe_mkdir_p(self.output_folder)
        print(f"DEBUG: Ensured output folder exists: {self.output_folder}")

        if force_load_plans or (self.plans is None):
            print("DEBUG: Loading plans file")
            self.load_plans_file()
            print("DEBUG: Loaded plans file into self.plans")

        print("DEBUG: Processing plans")
        self.process_plans(self.plans)
        print("DEBUG: Completed process_plans")

        print("DEBUG: Setting up data augmentation parameters")
        self.setup_DA_params()
        print("DEBUG: Completed setup_DA_params")

        if training:
            print("DEBUG: Initializing training data generators")
            self.folder_with_preprocessed_data = join(self.dataset_directory, f"{self.plans['data_identifier']}_stage{self.stage}")
            print(f"DEBUG: Set folder_with_preprocessed_data = {self.folder_with_preprocessed_data}")

            self.dl_tr, self.dl_val = self.get_basic_generators()
            print(f"DEBUG: Obtained basic generators: dl_tr={self.dl_tr}, dl_val={self.dl_val}")

            if self.unpack_data:
                print("DEBUG: Unpacking dataset")
                self.print_to_log_file("unpacking dataset")
                unpack_dataset(self.folder_with_preprocessed_data)
                self.print_to_log_file("done")
                # print("DEBUG: Completed unpacking dataset")
            else:
                print("DEBUG: Skipping dataset unpacking; training may be slow")
                self.print_to_log_file(
                    "INFO: Not unpacking data! Training may be slow..."
                )

            self.tr_gen, self.val_gen = get_default_augmentation(
                self.dl_tr, self.dl_val,
                self.data_aug_params['patch_size_for_spatialtransform'],
                self.data_aug_params
            )
            print(f"DEBUG: Created augmentation generators: tr_gen={self.tr_gen}, val_gen={self.val_gen}")

            self.print_to_log_file("TRAINING KEYS:\n %s" % (str(self.dataset_tr.keys())), also_print_to_console=False)
            # print("DEBUG: Logged training dataset keys")
            self.print_to_log_file("VALIDATION KEYS:\n %s" % (str(self.dataset_val.keys())), also_print_to_console=False)
            # print("DEBUG: Logged validation dataset keys")
        else:
            print("DEBUG: Skipping training data initialization (training=False)")

        print("DEBUG: Initializing network")
        self.initialize_network()
        print("DEBUG: Completed initialize_network")

        print("DEBUG: Initializing optimizer and scheduler")
        self.initialize_optimizer_and_scheduler()
        print("DEBUG: Completed initialize_optimizer_and_scheduler")

        self.was_initialized = True
        print(f"DEBUG: Set was_initialized = {self.was_initialized}")

    def initialize_network(self):
        print("DEBUG: Entering initialize_network")
        net_numpool = len(self.net_num_pool_op_kernel_sizes)
        print(f"DEBUG: Computed net_numpool = {net_numpool}")

        if self.threeD:
            print("DEBUG: Configuring 3D convolution, dropout, and norm ops")
            conv_op = nn.Conv3d
            dropout_op = nn.Dropout3d
            norm_op = nn.InstanceNorm3d
        else:
            print("DEBUG: Configuring 2D convolution, dropout, and norm ops")
            conv_op = nn.Conv2d
            dropout_op = nn.Dropout2d
            norm_op = nn.InstanceNorm2d
        print(f"DEBUG: Set conv_op={conv_op}, dropout_op={dropout_op}, norm_op={norm_op}")

        norm_op_kwargs = {'eps': 1e-5, 'affine': True}
        print(f"DEBUG: Set norm_op_kwargs = {norm_op_kwargs}")
        dropout_op_kwargs = {'p': 0, 'inplace': True}
        print(f"DEBUG: Set dropout_op_kwargs = {dropout_op_kwargs}")
        net_nonlin = nn.LeakyReLU
        print(f"DEBUG: Set net_nonlin = {net_nonlin}")
        net_nonlin_kwargs = {'negative_slope': 1e-2, 'inplace': True}
        print(f"DEBUG: Set net_nonlin_kwargs = {net_nonlin_kwargs}")

        print("DEBUG: Instantiating Generic_UNet network")
        self.network = Generic_UNet(
            self.num_input_channels, self.base_num_features, self.num_classes, net_numpool,
            self.conv_per_stage, 2, conv_op, norm_op, norm_op_kwargs, dropout_op,
            dropout_op_kwargs, net_nonlin, net_nonlin_kwargs, False, False,
            lambda x: x, InitWeights_He(1e-2), self.net_num_pool_op_kernel_sizes,
            self.net_conv_kernel_sizes, False, True, True
        )
        print(f"DEBUG: Created network instance: {self.network}")

        self.network.inference_apply_nonlin = softmax_helper
        print("DEBUG: Set network.inference_apply_nonlin to softmax_helper")

        if torch.cuda.is_available():
            self.network.cuda()
            print("DEBUG: Moved network to CUDA")


    def initialize_optimizer_and_scheduler(self):
        print("DEBUG: Entering initialize_optimizer_and_scheduler")
        assert self.network is not None, "self.initialize_network must be called first"
        # print(f"DEBUG: Network exists: {self.network}")
        self.optimizer = torch.optim.Adam(
            self.network.parameters(), self.initial_lr, weight_decay=self.weight_decay, amsgrad=True)
        print(f"DEBUG: Created optimizer = {self.optimizer}")
        self.lr_scheduler = lr_scheduler.ReduceLROnPlateau(
            self.optimizer, mode='min', factor=0.2,
            patience=self.lr_scheduler_patience, verbose=True,
            threshold=self.lr_scheduler_eps, threshold_mode="abs")
        print(f"DEBUG: Created lr_scheduler = {self.lr_scheduler}")

    # def plot_network_architecture(self):
    #     print("DEBUG: Entering plot_network_architecture")
    #     try:
    #         from batchgenerators.utilities_file_and_folder_operations import join
    #         import hiddenlayer as hl
    #         print("DEBUG: Imported join and hiddenlayer")
    #         if torch.cuda.is_available():
    #             print("DEBUG: CUDA available, building graph on GPU")
    #             g = hl.build_graph(self.network,torch.rand((1, self.num_input_channels, *self.patch_size)).cuda(), transforms=None)
    #         else:
    #             print("DEBUG: CUDA not available, building graph on CPU")
    #             g = hl.build_graph(self.network,torch.rand((1, self.num_input_channels, *self.patch_size)), transforms=None)
            
    #         print("DEBUG: Built hiddenlayer graph")
    #         g.save(join(self.output_folder, "network_architecture.pdf"))
    #         print(f"DEBUG: Saved graph to {self.output_folder}/network_architecture.pdf")
    #         # del g
    #         print("DEBUG: Deleted graph object")
    #     except Exception as e:
    #         print(f"DEBUG: Exception in plot_network_architecture: {e}")
    #         self.print_to_log_file("Unable to plot network architecture:")
    #         self.print_to_log_file(e)
    #         self.print_to_log_file("\nprinting the network instead:\n")
    #         self.print_to_log_file(self.network)
    #         self.print_to_log_file("\n")
    #     finally:
    #         if torch.cuda.is_available():
    #             torch.cuda.empty_cache()
    #             print("DEBUG: Emptied CUDA cache in finally block")
    def plot_network_architecture(self):
        pass    

    def save_debug_information(self):
        # print("DEBUG: Entering save_debug_information")
        dct = OrderedDict()
        # print("DEBUG: Created empty OrderedDict for debug info")
        for k in self.__dir__():
            if not k.startswith("__") and not callable(getattr(self, k)):
                dct[k] = str(getattr(self, k))
        # print(f"DEBUG: Collected attributes into dct, count={len(dct)}")
        for key in ['plans', 'intensity_properties', 'dataset', 'dataset_tr', 'dataset_val']:
            if key in dct:
                del dct[key]
                print(f"DEBUG: Removed {key} from dct")
        save_json(dct, join(self.output_folder, "debug.json"))
        print(f"DEBUG: Saved debug.json to {self.output_folder}")

        import shutil
        print("DEBUG: Imported shutil for copying plans file")
        shutil.copy(self.plans_file, join(self.output_folder_base, "plans.pkl"))
        print(f"DEBUG: Copied plans_file to {self.output_folder_base}/plans.pkl")

    def run_training(self):
        print("DEBUG: Entering run_training")
        self.save_debug_information()
        print("DEBUG: Called save_debug_information")
        super(nnUNetTrainer, self).run_training()
        print("DEBUG: Completed super().run_training()")

    def load_plans_file(self):
        """
        This is what actually configures the entire experiment. The plans file is generated by experiment planning
        :return:
        """        
        print("DEBUG: Entering load_plans_file")
        self.plans = load_pickle(self.plans_file)
        print(f"DEBUG: Loaded self.plans from {self.plans_file}")

    def process_plans(self, plans):
        print(f"DEBUG: Entering process_plans with plans keys: {list(plans.keys())}")
        if self.stage is None:
            print("DEBUG: self.stage is None, inferring single available stage")
            assert len(list(plans['plans_per_stage'].keys())) == 1, \
                "If self.stage is None then there can be only one stage in the plans file."
            self.stage = list(plans['plans_per_stage'].keys())[0]
            print(f"DEBUG: Inferred self.stage = {self.stage}")
        self.plans = plans
        print("DEBUG: Assigned self.plans")

        stage_plans = self.plans['plans_per_stage'][self.stage]
        print(f"DEBUG: Loaded stage_plans for stage {self.stage}: {stage_plans.keys()}")

        self.batch_size = stage_plans['batch_size']
        print(f"DEBUG: Set self.batch_size = {self.batch_size}")

        self.net_pool_per_axis = stage_plans['num_pool_per_axis']
        print(f"DEBUG: Set self.net_pool_per_axis = {self.net_pool_per_axis}")

        self.patch_size = np.array(stage_plans['patch_size']).astype(int)
        print(f"DEBUG: Set self.patch_size = {self.patch_size}")

        self.do_dummy_2D_aug = stage_plans['do_dummy_2D_data_aug']
        print(f"DEBUG: Set self.do_dummy_2D_aug = {self.do_dummy_2D_aug}")

        if 'pool_op_kernel_sizes' not in stage_plans:
            print("DEBUG: Missing pool_op_kernel_sizes → computing fallback")
            assert 'num_pool_per_axis' in stage_plans
            self.print_to_log_file("WARNING! old plans file missing pool_op_kernel_sizes. Fixing...")
            self.net_num_pool_op_kernel_sizes = []
            for i in range(max(self.net_pool_per_axis)):
                curr = []
                for j in self.net_pool_per_axis:
                    curr.append(2 if (max(self.net_pool_per_axis) - j) <= i else 1)
                self.net_num_pool_op_kernel_sizes.append(curr)
                print(f"DEBUG: Built level {i} kernel sizes: {curr}")
        else:
            self.net_num_pool_op_kernel_sizes = stage_plans['pool_op_kernel_sizes']
            print(f"DEBUG: Set self.net_num_pool_op_kernel_sizes = {self.net_num_pool_op_kernel_sizes}")

        if 'conv_kernel_sizes' not in stage_plans:
            print("DEBUG: Missing conv_kernel_sizes → using default")
            self.print_to_log_file("WARNING! old plans file missing conv_kernel_sizes. Fixing...")
            self.net_conv_kernel_sizes = [[3] * len(self.net_pool_per_axis)] * (max(self.net_pool_per_axis) + 1)
            print(f"DEBUG: Set default self.net_conv_kernel_sizes = {self.net_conv_kernel_sizes}")
        else:
            self.net_conv_kernel_sizes = stage_plans['conv_kernel_sizes']
            print(f"DEBUG: Set self.net_conv_kernel_sizes = {self.net_conv_kernel_sizes}")

        self.pad_all_sides = None
        print("DEBUG: Set self.pad_all_sides = None")

        self.intensity_properties = plans['dataset_properties']['intensityproperties']
        print(f"DEBUG: Set self.intensity_properties")

        self.normalization_schemes = plans['normalization_schemes']
        print("DEBUG: Set self.normalization_schemes")

        self.base_num_features = plans['base_num_features']
        print(f"DEBUG: Set self.base_num_features = {self.base_num_features}")

        self.num_input_channels = plans['num_modalities']
        print(f"DEBUG: Set self.num_input_channels = {self.num_input_channels}")

        self.num_classes = plans['num_classes'] + 1
        print(f"DEBUG: Set self.num_classes = {self.num_classes}")

        self.classes = plans['all_classes']
        print(f"DEBUG: Set self.classes = {self.classes}")

        self.use_mask_for_norm = plans['use_mask_for_norm']
        print(f"DEBUG: Set self.use_mask_for_norm = {self.use_mask_for_norm}")

        self.only_keep_largest_connected_component = plans['keep_only_largest_region']
        print(f"DEBUG: Set self.only_keep_largest_connected_component = {self.only_keep_largest_connected_component}")

        self.min_region_size_per_class = plans['min_region_size_per_class']
        print("DEBUG: Set self.min_region_size_per_class")

        self.min_size_per_class = None
        print("DEBUG: Set self.min_size_per_class = None")

        if plans.get('transpose_forward') is None or plans.get('transpose_backward') is None:
            print("WARNING! Missing transpose info → defaulting to [0,1,2]")
            plans['transpose_forward'] = [0, 1, 2]
            plans['transpose_backward'] = [0, 1, 2]
        self.transpose_forward = plans['transpose_forward']
        print(f"DEBUG: Set self.transpose_forward = {self.transpose_forward}")
        self.transpose_backward = plans['transpose_backward']
        print(f"DEBUG: Set self.transpose_backward = {self.transpose_backward}")

        if len(self.patch_size) == 2:
            self.threeD = False
        elif len(self.patch_size) == 3:
            self.threeD = True
        else:
            raise RuntimeError(f"invalid patch size: {self.patch_size}")
        print(f"DEBUG: Set self.threeD = {self.threeD}")

        if 'conv_per_stage' in plans:
            self.conv_per_stage = plans['conv_per_stage']
        else:
            self.conv_per_stage = 2
        print(f"DEBUG: Set self.conv_per_stage = {self.conv_per_stage}")


    def load_dataset(self):
        print(f"DEBUG: Entering load_dataset, folder = {self.folder_with_preprocessed_data}")
        self.dataset = load_dataset(self.folder_with_preprocessed_data)
        print(f"DEBUG: Loaded self.dataset with {len(self.dataset)} items")


    def get_basic_generators(self):
        print("DEBUG: Entering get_basic_generators")
        self.load_dataset()
        print("DEBUG: Called load_dataset()")
        self.do_split()
        print(f"DEBUG: Completed dataset split: train={len(self.dataset_tr)}, val={len(self.dataset_val)}")

        if self.threeD:
            print("DEBUG: Creating 3D DataLoaders")
            dl_tr = DataLoader3D(
                self.dataset_tr, self.basic_generator_patch_size, self.patch_size, self.batch_size,
                False, oversample_foreground_percent=self.oversample_foreground_percent,
                pad_mode="constant", pad_sides=self.pad_all_sides, memmap_mode='r'
            )
            print(f"DEBUG: Created dl_tr: {dl_tr}")
            dl_val = DataLoader3D(
                self.dataset_val, self.patch_size, self.patch_size, self.batch_size,
                False, oversample_foreground_percent=self.oversample_foreground_percent,
                pad_mode="constant", pad_sides=self.pad_all_sides, memmap_mode='r'
            )
            print(f"DEBUG: Created dl_val: {dl_val}")
        else:
            print("DEBUG: Creating 2D DataLoaders")
            dl_tr = DataLoader2D(
                self.dataset_tr, self.basic_generator_patch_size, self.patch_size, self.batch_size,
                oversample_foreground_percent=self.oversample_foreground_percent,
                pad_mode="constant", pad_sides=self.pad_all_sides, memmap_mode='r'
            )
            print(f"DEBUG: Created dl_tr: {dl_tr}")
            dl_val = DataLoader2D(
                self.dataset_val, self.patch_size, self.patch_size, self.batch_size,
                oversample_foreground_percent=self.oversample_foreground_percent,
                pad_mode="constant", pad_sides=self.pad_all_sides, memmap_mode='r'
            )
            print(f"DEBUG: Created dl_val: {dl_val}")

        return dl_tr, dl_val



    def preprocess_patient(self, input_files):
        """
        Used to predict new unseen data. Not used for the preprocessing of the training/test data
        :param input_files:
        :return:
        """        
        print(f"DEBUG: Entering preprocess_patient with input_files: {input_files}")
        from training_model_restore import recursive_find_python_class
        print("DEBUG: Imported recursive_find_python_class")
        preprocessor_name = self.plans.get('preprocessor_name')
        print(f"DEBUG: Retrieved preprocessor_name = {preprocessor_name}")
        if preprocessor_name is None:
            if self.threeD:
                preprocessor_name = "GenericPreprocessor"
            else:
                preprocessor_name = "PreprocessorFor2D"
            print(f"DEBUG: Defaulted preprocessor_name = {preprocessor_name}")

        print("DEBUG: Using preprocessor", preprocessor_name)
        preprocessor_class = recursive_find_python_class(
            "all_helper_fn_n_class", preprocessor_name, "all_helper_fn_n_class")
        print(f"DEBUG: Found preprocessor_class = {preprocessor_class}")
        assert preprocessor_class is not None, f"Could not find preprocessor {preprocessor_name}"

        preprocessor = preprocessor_class(
            self.normalization_schemes, self.use_mask_for_norm,
            self.transpose_forward, self.intensity_properties
        )
        print(f"DEBUG: Instantiated preprocessor = {preprocessor}")

        d, s, properties = preprocessor.preprocess_test_case(
            input_files,
            self.plans['plans_per_stage'][self.stage]['current_spacing']
        )
        print(f"DEBUG: Received preprocessed outputs d, s, properties")
        return d, s, properties

    def preprocess_predict_nifti(self, input_files: List[str], output_file: str = None,
                                 softmax_ouput_file: str = None, mixed_precision: bool = True) -> None:
        """
        Use this to predict new data
        :param input_files:
        :param output_file:
        :param softmax_ouput_file:
        :param mixed_precision:
        :return:
        """        
        print("DEBUG: Entering preprocess_predict_nifti")
        print("DEBUG: Preprocessing...")
        d, s, properties = self.preprocess_patient(input_files)
        print("DEBUG: Completed preprocess_patient")

        print("DEBUG: Predicting preprocessed data")
        pred = self.predict_preprocessed_data_return_seg_and_softmax(
            d,
            do_mirroring=self.data_aug_params["do_mirror"],
            mirror_axes=self.data_aug_params['mirror_axes'],
            use_sliding_window=True,
            step_size=0.5,
            use_gaussian=True,
            pad_border_mode='constant',
            pad_kwargs={'constant_values': 0},
            verbose=True,
            all_in_gpu=False,
            mixed_precision=mixed_precision
        )[1]
        print(f"DEBUG: Obtained pred shape {pred.shape}")

        pred = pred.transpose([0] + [i + 1 for i in self.transpose_backward])
        print(f"DEBUG: Transposed pred with transpose_backward = {self.transpose_backward}")

        if 'segmentation_export_params' in self.plans:
            seg_params = self.plans['segmentation_export_params']
            force_separate_z = seg_params['force_separate_z']
            interpolation_order = seg_params['interpolation_order']
            interpolation_order_z = seg_params['interpolation_order_z']
        else:
            force_separate_z = None
            interpolation_order = 1
            interpolation_order_z = 0
        print(f"DEBUG: Set export params: force_separate_z={force_separate_z}, interp_order={interpolation_order}, interp_order_z={interpolation_order_z}")

        print("DEBUG: Resampling to original spacing and exporting NIfTI")
        save_segmentation_nifti_from_softmax(
            pred, output_file, properties, interpolation_order,
            self.regions_class_order, None, None, softmax_ouput_file,
            None, force_separate_z=force_separate_z,
            interpolation_order_z=interpolation_order_z
        )
        print("DEBUG: Completed NIfTI export")

        print("done")

    def predict_preprocessed_data_return_seg_and_softmax(self, data: np.ndarray, do_mirroring: bool = True,
                                                         mirror_axes: Tuple[int] = None,
                                                         use_sliding_window: bool = True, step_size: float = 0.5,
                                                         use_gaussian: bool = True, pad_border_mode: str = 'constant',
                                                         pad_kwargs: dict = None, all_in_gpu: bool = False,
                                                         verbose: bool = True, mixed_precision: bool = True) -> Tuple[np.ndarray, np.ndarray]:
        """
        :param data:
        :param do_mirroring:
        :param mirror_axes:
        :param use_sliding_window:
        :param step_size:
        :param use_gaussian:
        :param pad_border_mode:
        :param pad_kwargs:
        :param all_in_gpu:
        :param verbose:
        :return:
        """
        print(f"DEBUG: Entering predict_preprocessed_data_return_seg_and_softmax\n"
              f"      data.shape={data.shape}, do_mirroring={do_mirroring}, "
              f"mirror_axes={mirror_axes}, use_sliding_window={use_sliding_window},\n"
              f"      step_size={step_size}, use_gaussian={use_gaussian}, "
              f"pad_border_mode={pad_border_mode}, pad_kwargs={pad_kwargs},\n"
              f"      all_in_gpu={all_in_gpu}, verbose={verbose}, mixed_precision={mixed_precision}")
        
        if pad_border_mode == 'constant' and pad_kwargs is None:
            pad_kwargs = {'constant_values': 0}
            print(f"DEBUG: pad_kwargs was None, set to {pad_kwargs}")

        if do_mirroring and mirror_axes is None:
            mirror_axes = self.data_aug_params['mirror_axes']
            print(f"DEBUG: mirror_axes was None, set from data_aug_params: {mirror_axes}")

        if do_mirroring:
            assert self.data_aug_params["do_mirror"], \
                "Cannot do mirroring as TTA when training was done without mirroring"
            print("DEBUG: Mirroring is enabled and was allowed during training")

        valid = (SegmentationNetwork, nn.DataParallel)
        assert isinstance(self.network, valid), \
            f"self.network must be SegmentationNetwork/nn.DataParallel, got {type(self.network)}"
        print(f"DEBUG: Network type check passed: {type(self.network)}")

        current_mode = self.network.training
        print(f"DEBUG: Saved current training mode = {current_mode}")
        self.network.eval()
        print("DEBUG: Switched network to eval()")

        ret = self.network.predict_3D(
            data,
            do_mirroring=do_mirroring,
            mirror_axes=mirror_axes,
            use_sliding_window=use_sliding_window,
            step_size=step_size,
            patch_size=self.patch_size,
            regions_class_order=self.regions_class_order,
            use_gaussian=use_gaussian,
            pad_border_mode=pad_border_mode,
            pad_kwargs=pad_kwargs,
            all_in_gpu=all_in_gpu,
            verbose=verbose,
            mixed_precision=mixed_precision
        )
        print(f"DEBUG: Received prediction tuple from network.predict_3D")

        self.network.train(current_mode)
        print(f"DEBUG: Restored network training mode = {current_mode}")

        return ret


    def validate(self, do_mirroring: bool = True, use_sliding_window: bool = True, step_size: float = 0.5,
                save_softmax: bool = True, use_gaussian: bool = True, overwrite: bool = True,
                validation_folder_name: str = 'validation_raw', debug: bool = False, all_in_gpu: bool = False,
                segmentation_export_kwargs: dict = None, run_postprocessing_on_folds: bool = True):
        """
        if debug=True then the temporary files generated for postprocessing determination will be kept
        """

        print(f"DEBUG: Entering validate(do_mirroring={do_mirroring}, "
            f"use_sliding_window={use_sliding_window}, step_size={step_size}, "
            f"save_softmax={save_softmax}, use_gaussian={use_gaussian}, overwrite={overwrite}, "
            f"validation_folder_name={validation_folder_name}, debug={debug}, all_in_gpu={all_in_gpu}, "
            f"segmentation_export_kwargs={segmentation_export_kwargs}, "
            f"run_postprocessing_on_folds={run_postprocessing_on_folds})")

        current_mode = self.network.training
        print(f"DEBUG: Saved current network training mode = {current_mode}")
        self.network.eval()
        print("DEBUG: Switched network to eval()")

        assert self.was_initialized, "must initialize, ideally with checkpoint (or train first)"
        print("DEBUG: Checked was_initialized")
        if self.dataset_val is None:
            print("DEBUG: dataset_val is None, loading dataset and splitting")
            self.load_dataset()
            self.do_split()
            print(f"DEBUG: Completed load and split: train={len(self.dataset_tr)}, val={len(self.dataset_val)}")

        # Determine export params
        if segmentation_export_kwargs is None:
            print("DEBUG: No segmentation_export_kwargs, using plans if available")
            if 'segmentation_export_params' in self.plans:
                segp = self.plans['segmentation_export_params']
                force_separate_z = segp['force_separate_z']
                interpolation_order = segp['interpolation_order']
                interpolation_order_z = segp['interpolation_order_z']
                print("DEBUG: Retrieved export params from plans")
            else:
                force_separate_z = None
                interpolation_order = 1
                interpolation_order_z = 0
                print("DEBUG: Using default export params")
        else:
            force_separate_z = segmentation_export_kwargs['force_separate_z']
            interpolation_order = segmentation_export_kwargs['interpolation_order']
            interpolation_order_z = segmentation_export_kwargs['interpolation_order_z']
            print("DEBUG: Retrieved export params from segmentation_export_kwargs")

        # predictions as they come from the network go here
        output_folder = join(self.output_folder, validation_folder_name)
        print(f"DEBUG: Set output_folder = {output_folder}")
        maybe_mkdir_p(output_folder)
        print(f"DEBUG: Ensured directory exists: {output_folder}")

        # this is for debug purposes
        my_input_args = {
            'do_mirroring': do_mirroring,
            'use_sliding_window': use_sliding_window,
            'step_size': step_size,
            'save_softmax': save_softmax,
            'use_gaussian': use_gaussian,
            'overwrite': overwrite,
            'validation_folder_name': validation_folder_name,
            'debug': debug,
            'all_in_gpu': all_in_gpu,
            'segmentation_export_kwargs': segmentation_export_kwargs
        }
        save_json(my_input_args, join(output_folder, "validation_args.json"))
        print(f"DEBUG: Saved validation_args.json with {my_input_args}")

        # Mirror axes
        if do_mirroring:
            if not self.data_aug_params['do_mirror']:
                raise RuntimeError("Cannot mirror: training was without mirroring")
            mirror_axes = self.data_aug_params['mirror_axes']
            print(f"DEBUG: Using mirror_axes = {mirror_axes}")
        else:
            mirror_axes = ()
            print("DEBUG: Mirroring disabled, mirror_axes=()")

        pred_gt_tuples = []
        export_pool = Pool(default_num_threads)
        print(f"DEBUG: Initialized multiprocessing Pool with {default_num_threads} threads")
        results = []

        # Loop through validation cases
        for k in self.dataset_val.keys():
            print(f"DEBUG: Validating case key = {k}")
            properties = load_pickle(self.dataset[k]['properties_file'])
            fname = properties['list_of_data_files'][0].split("/")[-1][:-12]
            print(f"DEBUG: Derived fname = {fname}")
            need_run = (overwrite
                        or not isfile(join(output_folder, fname + ".nii.gz"))
                        or (save_softmax and not isfile(join(output_folder, fname + ".npz"))))
            print(f"DEBUG: need_run = {need_run}")
            if need_run:
                data = np.load(self.dataset[k]['data_file'])['data']
                print(f"DEBUG: Loaded data shape = {data.shape}")
                data[-1][data[-1] == -1] = 0
                print("DEBUG: Corrected label -1 to 0 in last channel")

                softmax_pred = self.predict_preprocessed_data_return_seg_and_softmax(
                    data[:-1],
                    do_mirroring=do_mirroring,
                    mirror_axes=mirror_axes,
                    use_sliding_window=use_sliding_window,
                    step_size=step_size,
                    use_gaussian=use_gaussian,
                    all_in_gpu=all_in_gpu,
                    mixed_precision=self.fp16
                )[1]
                print(f"DEBUG: Retrieved softmax_pred shape = {softmax_pred.shape}")

                softmax_pred = softmax_pred.transpose([0] + [i+1 for i in self.transpose_backward])
                print(f"DEBUG: Transposed softmax_pred with transpose_backward = {self.transpose_backward}")

                softmax_fname = join(output_folder, fname + ".npz") if save_softmax else None
                print(f"DEBUG: softmax_fname = {softmax_fname}")

                """There is a problem with python process communication that prevents us from communicating objects
                larger than 2 GB between processes (basically when the length of the pickle string that will be sent is
                communicated by the multiprocessing.Pipe object then the placeholder (I think) does not allow for long
                enough strings (lol). This could be fixed by changing i to l (for long) but that would require manually
                patching system python code. We circumvent that problem here by saving softmax_pred to a npy file that will
                then be read (and finally deleted) by the Process. save_segmentation_nifti_from_softmax can take either
                filename or np.ndarray and will handle this automatically"""
                if np.prod(softmax_pred.shape) > (2e9/4*0.85):
                    np.save(join(output_folder, fname + ".npy"), softmax_pred)
                    softmax_pred = join(output_folder, fname + ".npy")
                    print(f"DEBUG: Saved large softmax_pred to .npy and set path = {softmax_pred}")

                # Queue export
                results.append(export_pool.starmap_async(
                    save_segmentation_nifti_from_softmax,
                    ((softmax_pred,
                    join(output_folder, fname + ".nii.gz"),
                    properties,
                    interpolation_order,
                    self.regions_class_order,
                    None, None,
                    softmax_fname,
                    None,
                    force_separate_z,
                    interpolation_order_z),)
                ))
                print(f"DEBUG: Queued save_segmentation_nifti_from_softmax for {fname}")

            pred_gt_tuples.append([
                join(output_folder, fname + ".nii.gz"),
                join(self.gt_niftis_folder, fname + ".nii.gz")
            ])
            print(f"DEBUG: Appended pred_gt tuple for {fname}")

        # Wait and finalize
        _ = [i.get() for i in results]
        print("DEBUG: Completed all export_pool results")
        self.print_to_log_file("finished prediction")
        print("DEBUG: Logged finished prediction")

        # evaluate raw predictions
        self.print_to_log_file("evaluation of raw predictions")
        task = self.dataset_directory.split("/")[-1]
        job_name = self.experiment_name
        _ = aggregate_scores(
            pred_gt_tuples,
            labels=list(range(self.num_classes)),
            json_output_file=join(output_folder, "summary.json"),
            json_name=f"{job_name} val tiled {use_sliding_window}",
            json_author="Fabian",
            json_task=task,
            num_threads=default_num_threads
        )
        print("DEBUG: Completed aggregate_scores")

        if run_postprocessing_on_folds:
            # in the old nnunet we would stop here. Now we add a postprocessing. This postprocessing can remove everything
            # except the largest connected component for each class. To see if this improves results, we do this for all
            # classes and then rerun the evaluation. Those classes for which this resulted in an improved dice score will
            # have this applied during inference as well            
            self.print_to_log_file("determining postprocessing")
            determine_postprocessing(
                self.output_folder,
                self.gt_niftis_folder,
                validation_folder_name,
                final_subf_name=validation_folder_name + "_postprocessed",
                debug=debug
            )
            print("DEBUG: Completed determine_postprocessing")
            # after this the final predictions for the vlaidation set can be found in validation_folder_name_base + "_postprocessed"
            # They are always in that folder, even if no postprocessing as applied!

        # detemining postprocesing on a per-fold basis may be OK for this fold but what if another fold finds another
        # postprocesing to be better? In this case we need to consolidate. At the time the consolidation is going to be
        # done we won't know what self.gt_niftis_folder was, so now we copy all the niftis into a separate folder to
        # be used later
        # Copy GT NIfTIs
        gt_nifti_folder = join(self.output_folder_base, "gt_niftis")
        print(f"DEBUG: Set gt_nifti_folder = {gt_nifti_folder}")
        maybe_mkdir_p(gt_nifti_folder)
        print(f"DEBUG: Ensured directory exists: {gt_nifti_folder}")
        for f in subfiles(self.gt_niftis_folder, suffix=".nii.gz"):
            print(f"DEBUG: Copying gt file {f}")
            success, attempts, e = False, 0, None
            while not success and attempts < 10:
                try:
                    shutil.copy(f, gt_nifti_folder)
                    success = True
                    print(f"DEBUG: Copied {f} successfully")
                except OSError as err:
                    attempts += 1
                    e = err
                    print(f"DEBUG: Copy attempt {attempts} failed with {err}")
                    sleep(1)
            if not success:
                print(f"DEBUG: Could not copy gt nifti file {f} into {gt_nifti_folder}")
                if e is not None:
                    raise e

        self.network.train(current_mode)
        print(f"DEBUG: Restored network to training mode = {current_mode}")


    def run_online_evaluation(self, output, target):
        print(f"DEBUG: Entering run_online_evaluation with output.shape={output.shape}, target.shape={target.shape}")
        with torch.no_grad():
            # print("DEBUG: torch.no_grad context entered")
            num_classes = output.shape[1]
            # print(f"DEBUG: num_classes = {num_classes}")
            output_softmax = softmax_helper(output)
            # print("DEBUG: Computed output_softmax")
            output_seg = output_softmax.argmax(1)
            # print("DEBUG: Computed output_seg via argmax")
            target = target[:, 0]
            # print(f"DEBUG: Squeezed target to shape={target.shape}")
            axes = tuple(range(1, len(target.shape)))
            # print(f"DEBUG: Summation axes = {axes}")

            tp_hard = torch.zeros((target.shape[0], num_classes - 1)).to(output_seg.device.index)
            fp_hard = torch.zeros((target.shape[0], num_classes - 1)).to(output_seg.device.index)
            fn_hard = torch.zeros((target.shape[0], num_classes - 1)).to(output_seg.device.index)
            # print("DEBUG: Initialized tp_hard, fp_hard, fn_hard tensors")

            for c in range(1, num_classes):
                tp_hard[:, c - 1] = sum_tensor((output_seg == c).float() * (target == c).float(), axes=axes)
                fp_hard[:, c - 1] = sum_tensor((output_seg == c).float() * (target != c).float(), axes=axes)
                fn_hard[:, c - 1] = sum_tensor((output_seg != c).float() * (target == c).float(), axes=axes)
                # print(f"DEBUG: Class {c} — tp, fp, fn computed")

            tp_hard = tp_hard.sum(0).detach().cpu().numpy()
            fp_hard = fp_hard.sum(0).detach().cpu().numpy()
            fn_hard = fn_hard.sum(0).detach().cpu().numpy()
            # print(f"DEBUG: Summed tp_hard={tp_hard}, fp_hard={fp_hard}, fn_hard={fn_hard}")

            self.online_eval_foreground_dc.append((2 * tp_hard) / (2 * tp_hard + fp_hard + fn_hard + 1e-8))
            self.online_eval_tp.append(tp_hard.tolist())
            self.online_eval_fp.append(fp_hard.tolist())
            self.online_eval_fn.append(fn_hard.tolist())
            # print("DEBUG: Appended to online_eval lists")

    def finish_online_evaluation(self):
        # print("DEBUG: Entering finish_online_evaluation")
        self.online_eval_tp = np.sum(self.online_eval_tp, axis=0)
        self.online_eval_fp = np.sum(self.online_eval_fp, axis=0)
        self.online_eval_fn = np.sum(self.online_eval_fn, axis=0)
        # print(f"DEBUG: Aggregated tp={self.online_eval_tp}, fp={self.online_eval_fp}, fn={self.online_eval_fn}")

        global_dc_per_class = [
            d for d in (2 * t / (2 * t + f + fn) if (2 * t + f + fn) > 0 else float('nan')
                        for t, f, fn in zip(self.online_eval_tp, self.online_eval_fp, self.online_eval_fn))
            if not np.isnan(d)
        ]
        # print(f"DEBUG: Computed global_dc_per_class={global_dc_per_class}")

        mean_dc = np.mean(global_dc_per_class)
        self.all_val_eval_metrics.append(mean_dc)
        print(f"DEBUG: Appended mean DC to all_val_eval_metrics: {mean_dc}")

        self.print_to_log_file("Average global foreground Dice:", np.round(global_dc_per_class, 4).tolist())
        self.print_to_log_file("(interpret this as an estimate; not exact.)")
        # print("DEBUG: Logged global Dice metrics")

        # Reset for next run
        self.online_eval_foreground_dc = []
        self.online_eval_tp = []
        self.online_eval_fp = []
        self.online_eval_fn = []
        # print("DEBUG: Reset online evaluation lists")

    def save_checkpoint(self, fname, save_optimizer=True):
        print(f"DEBUG: Entering save_checkpoint with fname={fname}, save_optimizer={save_optimizer}")
        super(nnUNetTrainer, self).save_checkpoint(fname, save_optimizer)
        # print("DEBUG: Called super().save_checkpoint()")
        info = OrderedDict()
        info['init'] = self.init_args
        # print(f"DEBUG: info['init'] = {self.init_args}")
        info['name'] = self.__class__.__name__
        # print(f"DEBUG: info['name'] = {info['name']}")
        info['class'] = str(self.__class__)
        # print(f"DEBUG: info['class'] = {info['class']}")
        info['plans'] = self.plans
        # print(f"DEBUG: info['plans'] keys = {list(self.plans.keys())}")

        write_pickle(info, fname + ".pkl")
        print(f"DEBUG: Saved checkpoint info to {fname}.pkl")

